/*! (c) Andrea Giammarchi */
const{is:t}=Object;let e;const s=t=>{const s=e;e=s||[];try{if(t(),!s)for(const{value:t}of e);}finally{e=s}};class n{constructor(t){this._=t}then(t){t(this.value)}toJSON(){return this.value}toString(){return this.value}valueOf(){return this.value}}let i;class o extends n{constructor(t,e,s,n){super(t),this.f=n,this.$=!0,this.r=new Set,this.s=new g(e,s)}get value(){if(this.$){const t=i;i=this;try{this.s.value=this._(this.s._)}finally{this.$=!1,i=t}}return this.s.value}}const c={async:!1,equals:!0},r=(t,e,s=c)=>new o(t,e,s,!1);let a;const l=[],u=()=>{},h=({s:t})=>{"function"==typeof t._&&(t._=t._())};class f extends o{constructor(t,e,s){super(t,e,s,!0),this.e=l}run(){return this.$=!0,this.value,this}stop(){this._=u,this.r.clear(),this.s.c.clear()}}class p extends f{constructor(t,e,s){super(t,e,s),this.i=0,this.a=!!s.async,this.m=!0,this.e=[]}get value(){this.a?this.async():this.sync()}async(){this.m&&(this.m=!1,queueMicrotask((()=>{this.m=!0,this.sync()})))}sync(){const t=a;(a=this).i=0,h(this),super.value,a=t}stop(){super.stop(),h(this);for(const t of this.e.splice(0))t.stop()}}const d=()=>!1;class g extends n{constructor(e,{equals:s}){super(e),this.c=new Set,this.s=!0===s?t:s||d}peek(){return this._}get value(){return i&&(this.c.add(i),i.r.add(this)),this._}set value(t){const s=this._;if(!this.s(this._=t,s)&&this.c.size){const t=[],s=[this];for(const e of s)for(const n of e.c)if(!n.$&&n.r.has(e))if(n.r.clear(),n.$=!0,n.f){t.push(n);const e=[n];for(const t of e)for(const s of t.e)s.r.clear(),s.$=!0,e.push(s)}else s.push(n.s);for(const s of t)e?e.push(s):s.value}}}const v=(t,e=c)=>new g(t,e),y={async:!1},b=(t,e)=>((t,e,s=c)=>{let n;if(a){const{i:i,e:o}=a,c=i===o.length;(c||o[i]._!==t)&&(c||o[i].stop(),o[i]=new p(t,e,s).run()),n=o[i],a.i++}else n=new p(t,e,s).run();return()=>{n.stop()}})(t,e,y);var w=(0,Object.freeze)([]),m=()=>{};const N=(t,e,s)=>{const{parentNode:n}=s,i=e.length;let o=t.length,c=i,r=0,a=0,l=null;for(;r<o||a<c;)if(o===r){const t=c<i?a?e[a-1].nextSibling:e[c-a]:s;for(;a<c;)n.insertBefore(e[a++],t)}else if(c===a)for(;r<o;)l&&l.has(t[r])||t[r].remove(),r++;else if(t[r]===e[a])r++,a++;else if(t[o-1]===e[c-1])o--,c--;else if(t[r]===e[c-1]&&e[a]===t[o-1]){const s=t[--o].nextSibling;n.insertBefore(e[a++],t[r++].nextSibling),n.insertBefore(e[--c],s),t[o]=e[c]}else{if(!l){l=new Map;let t=a;for(;t<c;)l.set(e[t],t++)}if(l.has(t[r])){const s=l.get(t[r]);if(a<s&&s<c){let i=r,u=1;for(;++i<o&&i<c&&l.get(t[i])===s+u;)u++;if(u>s-a){const i=t[r];for(;a<s;)n.insertBefore(e[a++],i)}else n.replaceChild(e[a++],t[r++])}else r++}else t[r++].remove()}return e},{isArray:T}=Array,{entries:S,getPrototypeOf:E,prototype:{isPrototypeOf:O}}=Object,{COMPONENT:k,ELEMENT:_,FRAGMENT:$,INTERPOLATION:A,STATIC:C}=class{static ATTRIBUTE=1;static COMPONENT=2;static ELEMENT=3;static FRAGMENT=4;static INTERPOLATION=5;static STATIC=6;get properties(){const{attributes:t}=this;if(t.length){const e={};for(const s of t)s.type<2?e[s.name]=s.value:Object.assign(e,s.value);return e}return null}},M=({childNodes:t},e)=>t[e],x=({children:t},e)=>t[e],I=({value:t,properties:e,children:s})=>t(e,...s),P=({name:t})=>"key"===t,B=(t,{content:e})=>t.reduce(M,e),R=(t,e)=>t.reduce(x,e),L=(t,e)=>{const s=null==e?"":String(e);s!==t.data&&(t.data=s)};
/*! (c) Andrea Giammarchi - ISC */var j=(t={})=>{const e=t.document||globalThis.document,s=new Map(t.plugins||[]),n=!!s.size,i=t.diff||N,o=t.effect||(t=>(t(),m)),c=t.getPeek||(t=>t.peek()),r=t.getValue||(t=>t.value),a=t.isSignal||(t.Signal?O.bind(t.Signal.prototype):()=>!1),l=t=>e.createTextNode(t),u=(t,e)=>{let s=v.get(t);return s||v.set(t,s={}),s[e]||(s[e]={})},h=(t,e)=>{t.dispose();const s=o((()=>{const s=I(e);s.id!==t.id?t=f(t,s,!1):t.update(s)}));return t.dispose=s,t},f=(t,e,s)=>e.type===k?h(t,e):((t,e,s)=>(t.dispose(),t=new p(e),s?t.dispose=o((()=>t.update(e))):t.update(e),t))(t,e,s);class p{constructor(t,e=!0){const[s,n]=e?M(t):[w,null];this._=e&&t.type===$,this.id=t.id,this.updates=s,this.content=n,this.dispose=m}get $(){const{content:t,_:e}=this;return e?(this._=!e,(this.content=(({childNodes:t})=>({childNodes:[...t]}))(t)).childNodes):[t]}update(t){for(const e of this.updates)e.call(this,t)}}const d=new p({id:null},!1),g={id:null,view:d},v=new WeakMap;let y;const b=new WeakMap,M=t=>{let e=b.get(t.id);if(!e){const s=[],n=V(t,s,[],w,!1);b.set(t.id,e=[s,n])}const[s,n]=e;return[s.slice(),n.cloneNode(!0)]},x=(t,e,s,n)=>{n?t.setAttribute(e,s):t[e]=s},j=(t,e,s,n,i)=>{if(a(s)){const c="ðŸ™Š"+e;c in n&&n[c](),n[c]=o((()=>{x(t,e,r(s),i)}))}else x(t,e,s,i)},W=(t,e,i,o)=>{if(n&&s.has(e))s.get(e)(t,i,o);else if(o[e]!==i)switch(o[e]=i,e){case"class":e+="Name";case"className":case"textContent":j(t,e,i,o,!1);break;case"ref":i.current=t;break;default:e.startsWith("on")?t[e.toLowerCase()]=i:e in t?j(t,e,i,o,!1):null==i?t.removeAttribute(e):j(t,e,i,o,!0)}},q=(t,e,s)=>function(n){const i={},o=B(e,this);(this.updates[s]=s=>{const{attributes:n}=R(e,s);for(const e of t){const t=n[e],{type:s,value:c}=t;if(s<2)W(o,t.name,c,i);else for(const[t,e]of S(c))W(o,t,e,i)}})(n)},z=(t,s)=>function(n){let o=w,c=!0,r=-1;const a=B(t,this),l=new Map;(this.updates[s]=s=>{const{value:n}=R(t,s),h=[];for(let t=0;t<n.length;t++){const e=n[t];c&&(c=!c,r=e.attributes.findIndex(P));const s=r<0?t:e.attributes[r].value;let{id:i,view:o}=l.get(s)||g;i!==(e.id||(e.id=u(a,t)))?(o=f(o,e,!1),l.set(s,{id:e.id,view:o})):o.update(e),h.push(...o.$)}if(h.length)o=i(o,h,a);else if(o!==w){const t=e.createRange();t.setStartBefore(o[0]),t.setEndAfter(o[o.length-1]),t.deleteContents(),l.clear(),o=w,c=!0}})(n)},F=(t,e)=>function(s){let n=w,o=d;const c=B(t,this);(this.updates[e]=e=>{o=h(o,R(t,e)),n=i(n,o.$,c)})(s)},G=(t,e)=>function(s){const n=B(t,this);(this.updates[e]=e=>{L(n,R(t,e).value)})(s)},D=(t,e)=>function(s){let n,a,u=m;const h=B(t,this),{value:p}=R(t,s),g=t=>{n!==t&&(u(),n=t,u=o(a))};if(y(c(p))){let t=w,e=d;a=()=>{const s=r(n);e=f(e,s,!1),t=i(t,e.$,h)}}else{const t=l("");h.replaceWith(t),a=()=>{L(t,r(n))}}this.updates[e]=e=>g(R(t,e).value),g(p)},J=(t,e)=>function(s){let n=w,o=d,c=null;const r=B(t,this);(this.updates[e]=e=>{e=R(t,e).value,c!==e.id?(c=e.id,o=f(o,e,!1),n=i(n,o.$,r)):e.type===k?o.update(I(e)):o.update(e)})(s)},U=({children:t},e,s,n,i)=>{for(let o=0;o<t.length;o++){const c=t[o];if(c.type===C)s.appendChild(l(c.value));else s.appendChild(V(t[o],e,[],n.concat(o),i))}},V=(t,s,n,i,o)=>{let c,r;const{length:u}=s;t:switch(t.type){case A:{const{value:e}=t;switch(!0){case y(e):c=J;break;case T(e):c=z;break;case a(e):c=D;break;default:r=l(""),s.push(G(i,u));break t}}case k:r=e.createComment("ðŸ™Š"),s.push((c||F)(i,u));break;case _:{const{attributes:c,name:a}=t,l=[a],h=[];for(let t=0;t<c.length;t++){const e=c[t];e.type===A||e.dynamic?P(e)||n.push(t):("is"===e.name&&l.push({is:e.value}),h.push(e))}n.length&&s.push(q(n,i,u)),r=o||(o="svg"===a)?e.createElementNS("http://www.w3.org/2000/svg",...l):e.createElement(...l);for(const{name:t,value:e}of h)x(r,t,e,!0);U(t,s,r,i,o);break}case $:r=e.createDocumentFragment(),U(t,s,r,i,o)}return r};return(t,e)=>{const s="function"==typeof t?t():t;y||(y=O.bind(E(s)));const n=f(v.get(e)||d,s,!0);v.set(e,n),e.replaceChildren(...n.$)}};const W=(t={})=>j({...t,Signal:n,effect:b,isSignal:void 0});export{p as Effect,f as FX,n as Signal,s as batch,r as computed,W as createRender,b as effect,v as signal};
