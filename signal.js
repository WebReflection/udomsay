/*! (c) Andrea Giammarchi */
let e=null;const t=t=>{let s=e;s||(e=new Set);try{t()}finally{if(!s){[e,s]=[null,e];for(const e of s)e._()}}},s=e=>{const t=[...e];return e.clear(),t};class n extends Set{constructor(e){super()._=e}dispose(){for(const e of s(this))e.delete(this),e.dispose?.()}}let i=null;const o=(e,t)=>{const s=new n((()=>{const n=i;i=s;try{t=e(t)}finally{i=n}}));return i&&i.add(s),s._(),()=>s.dispose()};class a extends Set{constructor(e){super()._=e}get value(){return i&&i.add(this.add(i)),this._}set value(t){if(this._!==t){this._=t;const n=!e;for(const t of s(this))n?t._():e.add(t)}}peek(){return this._}then(e){e(this.value)}toJSON(){return this.value}valueOf(){return this.value}toString(){return String(this.value)}}const r=e=>new a(e);class l extends a{constructor(e,t){super(t),this.dispose=o((()=>{super.value=e(this._)}))}get value(){return super.value}set value(e){throw new Error("computed is read-only")}}const c=(e,t)=>new l(e,t);var u=(0,Object.freeze)([]),d=()=>{};const h=(e,t,s)=>{const{parentNode:n}=s,i=t.length;let o=e.length,a=i,r=0,l=0,c=null;for(;r<o||l<a;)if(o===r){const e=a<i?l?t[l-1].nextSibling:t[a-l]:s;for(;l<a;)n.insertBefore(t[l++],e)}else if(a===l)for(;r<o;)c&&c.has(e[r])||e[r].remove(),r++;else if(e[r]===t[l])r++,l++;else if(e[o-1]===t[a-1])o--,a--;else if(e[r]===t[a-1]&&t[l]===e[o-1]){const s=e[--o].nextSibling;n.insertBefore(t[l++],e[r++].nextSibling),n.insertBefore(t[--a],s),e[o]=t[a]}else{if(!c){c=new Map;let e=l;for(;e<a;)c.set(t[e],e++)}if(c.has(e[r])){const s=c.get(e[r]);if(l<s&&s<a){let i=r,u=1;for(;++i<o&&i<a&&c.get(e[i])===s+u;)u++;if(u>s-l){const i=e[r];for(;l<s;)n.insertBefore(t[l++],i)}else n.replaceChild(t[l++],e[r++])}else r++}else e[r++].remove()}return t},{isArray:f}=Array,{getPrototypeOf:p,prototype:{isPrototypeOf:g}}=Object,{COMPONENT:v,ELEMENT:b,FRAGMENT:w,INTERPOLATION:N,STATIC:m}=class{static ATTRIBUTE=1;static COMPONENT=2;static ELEMENT=3;static FRAGMENT=4;static INTERPOLATION=5;static STATIC=6;get properties(){const{attributes:e}=this;if(e.length){const t={};for(const s of e)s.type<2?t[s.name]=s.value:Object.assign(t,s.value);return t}return null}},y=({childNodes:e},t)=>e[t],S=({children:e},t)=>e[t],T=({value:e,properties:t,children:s})=>e(t,...s),E=({name:e})=>"key"===e,O=(e,{content:t})=>e.reduce(y,t),k=(e,t)=>e.reduce(S,t),_=(e,t)=>{const s=null==t?"":String(t);s!==e.data&&(e.data=s)};
/*! (c) Andrea Giammarchi - ISC */var A=(e={})=>{const t=e.document||globalThis.document,s=new Map(e.plugins||[]),n=!!s.size,i=e.diff||h,o=e.effect||(e=>(e(),d)),a=e.getPeek||(e=>e.peek()),r=e.getValue||(e=>e.value),l=e.isSignal||(e.Signal?g.bind(e.Signal.prototype):()=>!1),c=e=>t.createTextNode(e),y=(e,t)=>{e.dispose();const s=o((()=>{const s=T(t);s.id!==e.id?e=S(e,s,!1):e.update(s)}));return e.dispose=s,e},S=(e,t,s)=>t.type===v?y(e,t):((e,t,s)=>(e.dispose(),e=new A(t),s?e.dispose=o((()=>e.update(t))):e.update(t),e))(e,t,s);class A{constructor(e,t=!0){const[s,n]=t?B(e):[u,null];this._=t&&e.type===w,this.id=e.id,this.updates=s,this.content=n,this.dispose=d}get $(){const{content:e,_:t}=this;return t?(this._=!t,(this.content=(({childNodes:e})=>({childNodes:[...e]}))(e)).childNodes):[e]}update(e){for(const t of this.updates)t.call(this,e)}}const C=new A({id:null},!1),M={id:null,view:C},x=new WeakMap;let I;const P=new WeakMap,B=e=>{let t=P.get(e.id);if(!t){const s=[],n=U(e,s,[],u,!1);P.set(e.id,t=[s,n])}const[s,n]=t;return[s.slice(),n.cloneNode(!0)]},R=(e,t,s,n)=>{n?e.setAttribute(t,s):e[t]=s},$=(e,t,s,n,i)=>{if(l(s)){const a="ðŸ™Š"+t;a in n&&n[a](),n[a]=o((()=>{R(e,t,r(s),i)}))}else R(e,t,s,i)},L=(e,t,i,o)=>{if(n&&s.has(t))s.get(t)(e,i,o);else if(o[t]!==i)switch(o[t]=i,t){case"class":t+="Name";case"className":case"textContent":$(e,t,i,o,!1);break;case"ref":i.current=e;break;default:t.startsWith("on")?e[t.toLowerCase()]=i:t in e?$(e,t,i,o,!1):null==i?e.removeAttribute(t):$(e,t,i,o,!0)}},W=(e,t,s)=>function(n){const i={},o=O(t,this);(this.updates[s]=s=>{const{attributes:n}=k(t,s);for(const t of e){const{name:e,value:s}=n[t];L(o,e,s,i)}})(n)},j=(e,s)=>function(n){let o=u,a=!0,r=-1;const l=O(e,this),c=new Map;(this.updates[s]=s=>{const{value:n}=k(e,s),d=[];for(let e=0;e<n.length;e++){const t=n[e];a&&(a=!a,r=t.attributes.findIndex(E));const s=r<0?e:t.attributes[r].value;let{id:i,view:o}=c.get(s)||M;i!==t.id?(o=S(o,t,!1),c.set(s,{id:t.id,view:o})):o.update(t),d.push(...o.$)}if(d.length)o=i(o,d,l);else if(o!==u){const e=t.createRange();e.setStartBefore(o[0]),e.setEndAfter(o[o.length-1]),e.deleteContents(),c.clear(),o=u,a=!0}})(n)},F=(e,t)=>function(s){let n=u,o=C;const a=O(e,this);(this.updates[t]=t=>{o=y(o,k(e,t)),n=i(n,o.$,a)})(s)},z=(e,t)=>function(s){const n=O(e,this);(this.updates[t]=t=>{_(n,k(e,t).value)})(s)},G=(e,t)=>function(s){let n,l,h=d;const f=O(e,this),{value:p}=k(e,s),g=e=>{n!==e&&(h(),n=e,h=o(l))};if(I(a(p))){let e=u,t=C;l=()=>{const s=r(n);t=S(t,s,!1),e=i(e,t.$,f)}}else{const e=c("");f.replaceWith(e),l=()=>{_(e,r(n))}}this.updates[t]=t=>g(k(e,t).value),g(p)},D=(e,t)=>function(s){let n=u,o=C,a=null;const r=O(e,this);(this.updates[t]=t=>{t=k(e,t).value,a!==t.id?(a=t.id,o=S(o,t,!1),n=i(n,o.$,r)):t.type===v?o.update(T(t)):o.update(t)})(s)},J=({children:e},t,s,n,i)=>{for(let o=0;o<e.length;o++){const a=e[o];if(a.type===m)s.appendChild(c(a.value));else s.appendChild(U(e[o],t,[],n.concat(o),i))}},U=(e,s,n,i,o)=>{let a,r;const{length:u}=s;e:switch(e.type){case N:{const{value:t}=e;switch(!0){case I(t):a=D;break;case f(t):a=j;break;case l(t):a=G;break;default:r=c(""),s.push(z(i,u));break e}}case v:r=t.createComment("ðŸ™Š"),s.push((a||F)(i,u));break;case b:{const{attributes:a,name:l}=e,c=[l],d=[];for(let e=0;e<a.length;e++){const t=a[e];t.type===N||t.dynamic?E(t)||n.push(e):("is"===t.name&&c.push({is:t.value}),d.push(t))}n.length&&s.push(W(n,i,u)),r=o||(o="svg"===l)?t.createElementNS("http://www.w3.org/2000/svg",...c):t.createElement(...c);for(const{name:e,value:t}of d)R(r,e,t,!0);J(e,s,r,i,o);break}case w:r=t.createDocumentFragment(),J(e,s,r,i,o)}return r};return(e,t)=>{const s="function"==typeof e?e():e;I||(I=g.bind(p(s)));const n=S(x.get(t)||C,s,!0);x.set(t,n),t.replaceChildren(...n.$)}};const C=(e={})=>A({...e,Signal:a,effect:o,isSignal:void 0});export{l as Computed,a as Signal,t as batch,c as computed,C as createRender,o as effect,r as signal};
