/*! (c) Andrea Giammarchi */
const{is:t}=Object;let e;const s=t=>{const s=e;e=s||[];try{if(t(),!s)for(const{value:t}of e);}finally{e=s}};class n{constructor(t){this._=t}then(){return this.value}toJSON(){return this.value}toString(){return this.value}valueOf(){return this.value}}let o;class i extends n{constructor(t,e,s,n){super(t),this.f=n,this.$=!0,this.r=new Set,this.s=new p(e,s)}get value(){if(this.$){const t=o;o=this;try{this.s.value=this._(this.s._)}finally{this.$=!1,o=t}}return this.s.value}}const r={async:!1,equals:!0},c=(t,e,s=r)=>new i(t,e,s,!1);let l;const h=()=>{},a=({s:t})=>{"function"==typeof t._&&(t._=t._())};class u extends i{constructor(t,e,s){super(t,e,s,!0),this.i=0,this.a=!!s.async,this.m=!0,this.e=[]}get value(){this.a?this.async():this.sync()}async(){this.m&&(this.m=!1,queueMicrotask((()=>{this.m=!0,this.sync()})))}sync(){const t=l,{e:e}=l=this;if(this.i=0,a(this),super.value,this.i<e.length)for(const t of e.splice(this.i))t.stop();for(const{value:t}of e);l=t}stop(){a(this),this._=h,this.r.clear(),this.s.c.clear();for(const t of this.e.splice(0))t.stop()}}const f=()=>!1;class p extends n{constructor(e,{equals:s}){super(e),this.c=new Set,this.s=!0===s?t:s||f}peek(){return this._}get value(){return o&&(this.c.add(o),o.r.add(this)),this._}set value(t){const s=this._;if(!this.s(this._=t,s)&&this.c.size){const t=[],s=[this];for(const e of s)for(const n of e.c)if(!n.$&&n.r.has(e))if(n.r.clear(),n.$=!0,n.f){t.push(n);const e=[n];for(const t of e)for(const s of t.e)s.r.clear(),s.$=!0,e.push(s)}else s.push(n.s);for(const s of t)e?e.push(s):s.value}}}const d=(t,e=r)=>new p(t,e),g={async:!1},y=(t,e)=>((t,e,s=r)=>{let n;if(l){const{i:o,e:i}=l;o!==i.length&&i[o]._===t||(i[o]=new u(t,e,s)),n=i[o],l.i++}else(n=new u(t,e,s)).value;return()=>{n.stop()}})(t,e,g)
/*! (c) Andrea Giammarchi - ISC */;var m,_,v="-"+Math.random().toFixed(6)+"%";try{m=document.createElement("template"),_="tabindex","content"in m&&(m.innerHTML='<p tabindex="'+v+'"></p>',m.content.childNodes[0].getAttribute(_)==v)||(v="_dt: "+v.slice(1,-1)+";",!0)}catch(t){}var k=/^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;const{replace:w}="",b=/[&<>'"]/g,x={"&":"&amp;","<":"&lt;",">":"&gt;","'":"&#39;",'"':"&quot;"},$=t=>x[t],N=t=>w.call(t,b,$);var M=(t,e,s,n,o)=>{const i=s.length;let r=e.length,c=i,l=0,h=0,a=null;for(;l<r||h<c;)if(r===l){const e=c<i?h?n(s[h-1],-0).nextSibling:n(s[c-h],0):o;for(;h<c;)t.insertBefore(n(s[h++],1),e)}else if(c===h)for(;l<r;)a&&a.has(e[l])||t.removeChild(n(e[l],-1)),l++;else if(e[l]===s[h])l++,h++;else if(e[r-1]===s[c-1])r--,c--;else if(e[l]===s[c-1]&&s[h]===e[r-1]){const o=n(e[--r],-1).nextSibling;t.insertBefore(n(s[h++],1),n(e[l++],-1).nextSibling),t.insertBefore(n(s[--c],1),o),e[r]=s[c]}else{if(!a){a=new Map;let t=h;for(;t<c;)a.set(s[t],t++)}if(a.has(e[l])){const o=a.get(e[l]);if(h<o&&o<c){let i=l,u=1;for(;++i<r&&i<c&&a.get(e[i])===o+u;)u++;if(u>o-h){const i=n(e[l],0);for(;h<o;)t.insertBefore(n(s[h++],1),i)}else t.replaceChild(n(s[h++],1),n(e[l++],-1))}else l++}else t.removeChild(n(e[l++],-1))}return s};
/*! (c) Andrea Giammarchi - ISC */const S=[],j=[],{isArray:W}=Array,{entries:A}=Object,C=new Map,q=(t,e)=>{const s=e?t.value:t;return null==s?"":s},B=t=>{switch(t){case"__token":case"key":case"is":return!1}return!0},O=(t,e)=>t[e].args,T=(t,e,s)=>{for(let n=0;n<e;n++)({args:s}=s[t[n]]);return s[t[e]].value},E=({childNodes:t},e)=>t[e],L=(t,e)=>{if(t===S)return e.value;if(t!==j)for(const s of t)e[s]=e[s].value;return e};let H=!1;const z=(t,e)=>{H=!0,C.set(t,e)},F=(t,e,s)=>{H&&C.has(e)?C.get(e)(t,e,s):"ref"===e?s.current=t:("class"===e?e+="Name":e.startsWith("on")&&(e=e.toLowerCase()),e in t?t[e]!==s&&(t[e]=s):null==s?t.removeAttribute(e):t.setAttribute(e,s))};
/*! (c) Andrea Giammarchi - ISC */
class J{constructor(t,e,s,n,o){this.fragment="symbol"==t,this.type=t,this.child=e,this.tree=s,this.details=n,this.html=o}next(t,e,s){return new J(t,this.child.concat(e),s,this.details,this.html)}push(t,e=!1,s=this.child,n=this.tree){this.details.push({child:s,tree:n,props:t,hole:e})}}class D{constructor(t){this.value=t}}class G{constructor(){this.__token=null,this.store=null,this.nodes=j}}class I extends G{constructor(){super(),this.key=void 0}}class K{constructor(t){this.args=t,this.updates=[]}refresh(t){t!==this.args&&(this.args=t,this.update())}update(){for(const t of this.updates)t(this.args)}}class P extends K{constructor(t){super(t),this.init=!0,this.keys=j,this.result=null,this.dispose=y((()=>{const{init:t,args:e}=this,[s,n,...o]=e;if(t&&(this.init=!1,n))if(n instanceof D)this.keys=S;else{let t=j;for(const[e,s]of A(n))s instanceof D&&(t===j?t=[]:t).push(e);this.keys=t}this.result=s(L(this.keys,n),...o),t||this.update()}))}refresh(t){if(t!==this.args){this.args=t;const[e,s,...n]=t;this.result=e(L(this.keys,s),...n),this.update()}}update(){const{updates:t,result:{args:e}}=this;for(const s of t)s(e)}}
/*! (c) Andrea Giammarchi - ISC */const Q=Symbol();function R(t){return{type:typeof t,args:arguments}}const U=t=>new D(t),V=new WeakMap,X=(t,e)=>{"function"==typeof t&&(t=t());const{type:s,args:n}=t,{__token:o}=n[1];let i=V.get(e);if(!i||i.__token!==o){const[t,r]=at(o,s,n);V.set(e,i={__token:o,updates:[]}),e.replaceChildren(ot(t,r,i.updates))}for(const t of i.updates)t(n)};let{document:Y}=globalThis;const Z=t=>{Y=t};function tt(t,e){const{type:s,html:n}=this,{length:o}=arguments;switch(s){case"string":if(n.push(`<${t}`),e){const{is:t}=e;if(t&&n.push(` is="${t}"`),e instanceof D)this.push(S);else{const t=[];for(const[s,o]of A(e))B(s)&&(o instanceof D?t.push(s):n.push(` ${"className"===s?"class":s}="${N(o)}"`));t.length&&this.push(t)}}return 2===o?n.push(k.test(t)?" />":`></${t}>`):(n.push(">"),it.apply(this,arguments),n.push(`</${t}>`)),1;case"function":return n.push("\x3c!--ðŸ™Š--\x3e"),this.push(j),1;case"symbol":return it.apply(this,arguments)}throw new Error(t)}const et=t=>t,st=(t,e,s,n)=>{const o=ot(t,e,s);return n?[o]:[...o.childNodes]},nt=(t,e,s)=>{let n;if(t){const{length:t}=e;if(t){const o=e[t-1];n=e.slice(0,-1).concat(o+s)}else n=j}else n=e.concat(s);return n},ot=(t,e,s)=>{const o=Y.importNode(t,!0);return((t,e,s)=>{for(const{child:o,tree:i,props:r,hole:c}of e){const e=i.reduce(E,t),l=o.length-1;if(r===j){const t=s.push(c?i=>{const r=T(o,l,i);if("object"==typeof r)if(W(r)){const{parentNode:n}=e,c=[],l={};let h=0,a=[];(s[t]=(t,s=T(o,i,t))=>{const{length:i}=c,r=[];for(h=0;h<s.length;h++){const t=s[h],{__token:e,key:n}=t.args[1],o=void 0!==n;let i=c[h]||(c[h]=new I);o&&n===i.key&&e===i.__token?ft(i,t):o&&l[n]?ft(i=c[h]=l[n],t):(o&&(i.key=n,l[n]=i),ut(i,e,t)),r.push(...i.nodes)}h<i&&c.splice(h),a=M(n,a,r,et,e)})(i,r)}else{const c=r instanceof n;if(c&&"object"!=typeof r.value)s[t]=dt(o,l,e,r,!0);else{const{parentNode:n}=e,h=new G;(s[t]=(t,s=T(o,l,t))=>{const i=c?s.value:s,{__token:r}=i.args[1];if(r===h.__token)ft(h,i);else{const{nodes:t}=h;ut(h,r,i),M(n,t,h.nodes,et,e)}})(i,r)}}else s[t]=dt(o,l,e,r,!1)}:n=>{const[i,[r,c]]=ct(o.reduce(O,n));e.replaceWith(ot(r,c,i.updates)),s[t]=t=>{i.refresh(o.reduce(O,t))},i.update()})-1}else s.push(r===S?t=>{const s=o.reduce(O,t)[1].value;for(const[t,n]of A(s))B(t)&&F(e,t,n)}:t=>{const s=o.reduce(O,t)[1];for(const t of r)F(e,t,s[t].value)})}})(o,e,s),o};function it(t,e){const{fragment:s,child:n,tree:o,html:i}=this,r=s&&!e?.__token;let c=0;for(let t=2;t<arguments.length;t++){const e=arguments[t];if("object"==typeof e)if(e instanceof D)i.push("\x3c!--ðŸ™Š--\x3e"),this.push(j,!0,n.concat(t),nt(r,o,c++));else{const{type:s,args:n}=e;c+=tt.apply(this.next(s,t,nt(r,o,c)),n)}else c++,i.push(e)}return c}const rt=new WeakMap,ct=t=>{const e=new P(t);let s=rt.get(t[0]);if(!s){const{type:n,args:o}=e.result;rt.set(t[0],s=lt.apply(n,o))}return[e,s]};function lt(){const t=new J(this,j,j,[],[]);tt.apply(t,arguments);const e=Y.createElement("template");e.innerHTML=t.html.join("");const{content:s}=e;return["symbol"==this?s:s.childNodes[0],t.details]}const ht=new WeakMap,at=(t,e,s)=>{let n=ht.get(t);return n||ht.set(t,n=lt.apply(e,s)),n},ut=(t,e,s)=>{if(t.__token=e,"function"===s.type){const[e,[n,o]]=ct(s.args),{result:i,updates:r}=t.store=e;t.nodes=st(n,o,r,"symbol"!==i.type)}else pt(t,e,s,"string"===s.type);t.store.update()},ft=({store:t},{args:e})=>{t.refresh(e)},pt=(t,e,{type:s,args:n},o)=>{const[i,r]=at(e,s,n),{updates:c}=t.store=new K(n);t.nodes=st(i,r,c,o)},dt=(t,e,s,n,o)=>{const i=Y.createTextNode(q(n,o));return s.replaceWith(i),s=>{i.data=q(T(t,e,s),o)}};export{Q as Fragment,n as Signal,s as batch,c as computed,R as createElement,y as effect,U as interpolation,X as render,d as signal,Z as useDocument,z as useProperty};
