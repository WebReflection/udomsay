/*! (c) Andrea Giammarchi */
const{is:t}=Object;let e;const s=t=>{const s=e;e=s||[];try{if(t(),!s)for(const{value:t}of e);}finally{e=s}};class n{constructor(t){this._=t}then(){return this.value}toJSON(){return this.value}toString(){return this.value}valueOf(){return this.value}}let o;class r extends n{constructor(t,e,s,n){super(t),this.f=n,this.$=!0,this.r=new Set,this.s=new p(e,s)}get value(){if(this.$){const t=o;o=this;try{this.s.value=this._(this.s._)}finally{this.$=!1,o=t}}return this.s.value}}const i={async:!1,equals:!0},c=(t,e,s=i)=>new r(t,e,s,!1);let l;const h=()=>{},a=({s:t})=>{"function"==typeof t._&&(t._=t._())};class u extends r{constructor(t,e,s){super(t,e,s,!0),this.i=0,this.a=!!s.async,this.m=!0,this.e=[]}get value(){this.a?this.async():this.sync()}async(){this.m&&(this.m=!1,queueMicrotask((()=>{this.m=!0,this.sync()})))}sync(){const t=l,{e:e}=l=this;if(this.i=0,a(this),super.value,this.i<e.length)for(const t of e.splice(this.i))t.stop();for(const{value:t}of e);l=t}stop(){a(this),this._=h,this.r.clear(),this.s.c.clear();for(const t of this.e.splice(0))t.stop()}}const f=()=>!1;class p extends n{constructor(e,{equals:s}){super(e),this.c=new Set,this.s=!0===s?t:s||f}peek(){return this._}get value(){return o&&(this.c.add(o),o.r.add(this)),this._}set value(t){const s=this._;if(!this.s(this._=t,s)&&this.c.size){const t=[],s=[this];for(const e of s)for(const n of e.c)if(!n.$&&n.r.has(e))if(n.r.clear(),n.$=!0,n.f){t.push(n);const e=[n];for(const t of e)for(const s of t.e)s.r.clear(),s.$=!0,e.push(s)}else s.push(n.s);for(const s of t)e?e.push(s):s.value}}}const d=(t,e=i)=>new p(t,e),g={async:!1},y=(t,e)=>((t,e,s=i)=>{let n;if(l){const{i:o,e:r}=l;o!==r.length&&r[o]._===t||(r[o]=new u(t,e,s)),n=r[o],l.i++}else(n=new u(t,e,s)).value;return()=>{n.stop()}})(t,e,g)
/*! (c) Andrea Giammarchi - ISC */,m=[],{isArray:v}=Array,{entries:_}=Object,k=(t,e)=>{const s=e?t.value:t;return null==s?"":s},w=t=>{switch(t){case"__token":case"key":case"is":return!1}return!0},b=(t,e)=>t[e].args,x=(t,e,s)=>{for(let n=0;n<e;n++)({args:s}=s[t[n]]);return s[t[e]].value},$=({childNodes:t},e)=>t[e],N=new Map;let S=!1;const j=(t,e)=>{S=!0,N.set(t,e)},M=(t,e,s,n)=>{if(S&&N.has(e))N.get(e)(t,s,n);else if(n[e]!==s)switch(n[e]=s,e){case"class":e+="Name";case"className":case"textContent":t[e]=s;break;case"ref":s.current=t;break;default:e.startsWith("on")?t[e.toLowerCase()]=s:e in t?t[e]=s:null==s?t.removeAttribute(e):t.setAttribute(e,s)}},A=(t,e,s,n)=>{const o=s.length;let r=e.length,i=o,c=0,l=0,h=null;for(;c<r||l<i;)if(r===c){const e=i<o?l?s[l-1].nextSibling:s[i-l]:n;for(;l<i;)t.insertBefore(s[l++],e)}else if(i===l)for(;c<r;)h&&h.has(e[c])||e[c].remove(),c++;else if(e[c]===s[l])c++,l++;else if(e[r-1]===s[i-1])r--,i--;else if(e[c]===s[i-1]&&s[l]===e[r-1]){const n=e[--r].nextSibling;t.insertBefore(s[l++],e[c++].nextSibling),t.insertBefore(s[--i],n),e[r]=s[i]}else{if(!h){h=new Map;let t=l;for(;t<i;)h.set(s[t],t++)}if(h.has(e[c])){const n=h.get(e[c]);if(l<n&&n<i){let o=c,a=1;for(;++o<r&&o<i&&h.get(e[o])===n+a;)a++;if(a>n-l){const o=e[c];for(;l<n;)t.insertBefore(s[l++],o)}else t.replaceChild(s[l++],e[c++])}else c++}else e[c++].remove()}return s},B=[];class C{constructor(t,e,s,n,o){this.fragment="symbol"===t,this.type=t,this.child=e,this.tree=s,this.ops=n,this.html=o}next(t,e,s){return new C(t,this.child.concat(e),s,this.ops,this.html)}push(t,e=!1,s=this.child,n=this.tree){this.ops.push({child:s,tree:n,props:t,hole:e})}}class W{constructor(t){this.value=t}}class q{constructor(){this.__token=null,this.store=null,this.nodes=m}}class O extends q{constructor(t){super().key=t}}class E{constructor(t){this.args=t,this.updates=[]}refresh(t){t!==this.args&&(this.args=t,this.update())}update(){for(const t of this.updates)t(this.args)}}class T extends E{constructor(t){super(t),this.init=!0,this.keys=m,this.result=null,this.dispose=y((()=>{const{init:t,args:e}=this;let[s,n,...o]=e;if(t&&(this.init=!1,n))if(n instanceof W)this.keys=B,n=n.value;else{let t=m;for(const[e,s]of _(n))s instanceof W&&((t===m?t=[]:t).push(e),n[e]=s.value);this.keys=t}this.result=s(n,...o),t||this.update()}))}refresh(t){if(t!==this.args){let[e,s,...n]=this.args=t;const{keys:o}=this;if(o===B)s=s.value;else if(o!==m)for(const t of o)s[t]=s[t].value;this.result=e(s,...n),this.update()}}update(){const{updates:t,result:{args:e}}=this;for(const s of t)s(e)}}
/*! (c) Andrea Giammarchi - ISC */const L=/^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i,z=/[&<>'"]/g,H=t=>J[t],J={"&":"&amp;","<":"&lt;",">":"&gt;","'":"&#39;",'"':"&quot;"},R=t=>t.replace(z,H);
/*! (c) Andrea Giammarchi - ISC */function D(t,e){const s=new C(t,m,m,[],[]);return G.apply(s,e),{ops:s.ops,html:s.html.join("")}}const F=(t,e,s)=>{let n;if(t){const{length:t}=e;if(t){const o=e[t-1];n=e.slice(0,-1).concat(o+s)}else n=m}else n=e.concat(s);return n};function G(t,e){const{type:s,html:n}=this,{length:o}=arguments;switch(s){case"string":if(n.push(`<${t}`),e){const{is:t}=e;if(t&&n.push(` is="${t}"`),e instanceof W)this.push(m);else{const t=[];for(const[s,o]of _(e))w(s)&&(o instanceof W?t.push(s):n.push(` ${"className"===s?"class":s}="${R(o)}"`));t.length&&this.push(t)}}return 2===o?n.push(L.test(t)?" />":`></${t}>`):(n.push(">"),I.apply(this,arguments),n.push(`</${t}>`)),1;case"function":return n.push("\x3c!--ðŸ™Š--\x3e"),this.push(null),1;case"symbol":return I.apply(this,arguments)}throw new Error(t)}function I(t,e){const{fragment:s,child:n,tree:o,html:r}=this,i=s&&!e?.__token;let c=0;for(let t=2;t<arguments.length;t++){const e=arguments[t];if("object"==typeof e)if(e instanceof W)r.push("\x3c!--ðŸ™Š--\x3e"),this.push(null,!0,n.concat(t),F(i,o,c++));else{const{type:s,args:n}=e;c+=G.apply(this.next(s,t,F(i,o,c)),n)}else c++,r.push(e)}return c}
/*! (c) Andrea Giammarchi - ISC */const K=Symbol();function P(t){return{type:typeof t,args:arguments}}const Q=t=>new W(t),U=new WeakMap,V=(t,e)=>{"function"==typeof t&&(t=t());const{type:s,args:n}=t,{__token:o}=n[1];let r=U.get(e);if(!r||r.__token!==o){const[t,i]=ot(o,s,n);U.set(e,r={__token:o,updates:[]}),e.replaceChildren(et(t,i,r.updates))}for(const t of r.updates)t(n)};let{document:X}=globalThis;const Y=t=>{X=t},Z=(t,{html:e,ops:s})=>{const n=X.createElement("template");n.innerHTML=e;const{content:o}=n;return["symbol"===t?o:o.childNodes[0],s]},tt=(t,e,s,n)=>{const o=et(t,e,s);return n?[o]:[...o.childNodes]},et=(t,e,s)=>{const o=X.importNode(t,!0);return((t,e,s)=>{for(const{child:o,tree:r,props:i,hole:c}of e){const e=r.reduce($,t);if(i){const t={};s.push(i.length?s=>{const n=o.reduce(b,s)[1];for(const s of i)M(e,s,n[s].value,t)}:s=>{const n=o.reduce(b,s)[1].value;for(const[s,o]of _(n))w(s)&&M(e,s,o,t)})}else{const t=o.length-1,r=s.push(c?i=>{const c=x(o,t,i);if("object"==typeof c)if(v(c)){const{parentNode:t}=e;let n=!1,l=null,h=m,a=m;(s[r]=(s,r=x(o,u,s))=>{const i=[],c=[],{length:u}=h;let f=0;for(;f<r.length;f++){const t=f<u,e=r[f],{__token:s,key:o}=e.args[1];n||void 0===o||(n=!0,l={});let a=t?h[f]:null;t&&s===a.__token&&(!n||o.value===a.key)||n&&(a=l[o.value])?it(a,e):(n?(a=new O(o.value),l[o.value]=a):a=new q,rt(a,s,e)),c.push(a),i.push(...a.nodes)}if(f){if(n)for(;f<u;f++)delete l[h[f].key];a=A(t,a,i,e),h=c}else{const{length:t}=a;if(t){const e=X.createRange();e.setStartBefore(a[0]),e.setEndAfter(a[t-1]),e.deleteContents(),a=m,n&&(l={})}h=m}})(i,c)}else{const l=c instanceof n;if(l&&"object"!=typeof c.value)s[r]=lt(o,t,e,c,!0);else{const{parentNode:n}=e,h=new q;(s[r]=(s,r=x(o,t,s))=>{const i=l?r.value:r,{__token:c}=i.args[1];if(c===h.__token)it(h,i);else{const{nodes:t}=h;rt(h,c,i),A(n,t,h.nodes,e)}})(i,c)}}else s[r]=lt(o,t,e,c,!1)}:t=>{const[n,[i,c]]=nt(o.reduce(b,t));e.replaceWith(et(i,c,n.updates)),s[r]=t=>{n.refresh(o.reduce(b,t))},n.update()})-1}}})(o,e,s),o},st=new WeakMap,nt=t=>{const e=new T(t);let s=st.get(t[0]);if(!s){const{type:n,args:o}=e.result;st.set(t[0],s=Z(n,D(n,o)))}return[e,s]},ot=(t,e,s)=>t.info||(t.info=Z(e,D(e,s))),rt=(t,e,s)=>{if(t.__token=e,"function"===s.type){const[e,[n,o]]=nt(s.args),{result:r,updates:i}=t.store=e;t.nodes=tt(n,o,i,"symbol"!==r.type)}else ct(t,e,s,"string"===s.type);t.store.update()},it=({store:t},{args:e})=>{t.refresh(e)},ct=(t,e,{type:s,args:n},o)=>{const[r,i]=ot(e,s,n),{updates:c}=t.store=new E(n);t.nodes=tt(r,i,c,o)},lt=(t,e,s,n,o)=>{const r=X.createTextNode(k(n,o));return s.replaceWith(r),s=>{r.data=k(x(t,e,s),o)}};export{K as Fragment,n as Signal,s as batch,c as computed,P as createElement,y as effect,Q as interpolation,V as render,d as signal,Y as useDocument,j as useProperty};
